import logging
from enum import Enum
from typing import Any, Dict, Optional, Union

import sentry_sdk
from sentry_sdk.integrations.logging import LoggingIntegration


class EventTracker:
    # TODO: add a event_handler rate

    @classmethod
    def init(
        cls,
        environment: str,
        sentry_dsn: str,
        sentry_trace_sample_rate: float = 0,
    ):
        """

        initialize EventTracker.

        Tracing is used to measure the performance of request and used to identify bottlenecks in the application.
        However, it can generate a large volume of data and may incur additional costs depending on the Sentry plan.
        Initially is set to 0, which means no requests will be traced. When thinking into set it, consider the following factors:

        1. The performance impact of tracing on your application.
            Higher sample rates may provide more detailed insights but can also introduce overhead.
        2. The volume of data generated by tracing.
            Higher sample rates will result in more data being sent to Sentry, which may impact your usage limits and costs.

        Args:
            environment: Deployment environment
            sentry_dsn: Sentry Data Source Name (DSN) for project
            sentry_trace_sample_rate: Sampling rate for tracing (0 to disable, 0.5 to half, 1 to all)
        """

        # TODO: open-telemetry integration

        # Sentry Config

        # Set sentry to not capture error logs as issues
        sentry_logging_integration = LoggingIntegration(
            level=logging.DEBUG,
            event_level=None,
        )

        # Set tracing_sample_rate
        sentry_tracing_config = (
            {"enable_tracing": False}
            if sentry_trace_sample_rate == 0
            else {
                "traces_sample_rate": sentry_trace_sample_rate,
                "enable_tracing": True,
            }
        )

        sentry_sdk.init(
            dsn=sentry_dsn,
            environment=environment,
            integrations=[sentry_logging_integration],
            **sentry_tracing_config,
        )

    @staticmethod
    def _extract_value(value: Any) -> Any:
        """Extract value from enum or return as-is"""
        return value.value if isinstance(value, Enum) else value

    @classmethod
    def set_contexts(cls, context: Dict[Union[str, Enum], Dict]) -> None:
        """Set context data on Sentry"""
        context = context

        for key, value in context.items():
            sentry_sdk.set_context(cls._extract_value(key), value)

    @classmethod
    def set_tags(cls, tags: Dict[Union[str, Enum], Union[str, Enum]]) -> None:
        """Set tags (for filtering/indexing)"""
        tags = tags

        for key, value in tags.items():
            sentry_sdk.set_tag(cls._extract_value(key), cls._extract_value(value))

    @classmethod
    def track(
        cls,
        event: Union[str, Enum, Exception],
        *,
        tags: Optional[Dict[Union[str, Enum], Any]] = None,
        context: Optional[Dict[Union[str, Enum], Dict]] = None,
        level: Optional[str] = None,
    ) -> None:
        """
        Track an event with tags, context, and error handling

        Args:
            event: Event name or enum or Exception
            tags: Key-value pairs for indexing and filtering
            context: Rich data for detailed event analysis
            level: Severity level (info, warning, error)
        """
        if tags:
            cls.set_tags(tags)

        if context:
            cls.set_contexts(context)

        if isinstance(event, Exception):
            sentry_sdk.capture_exception(event)
        else:
            sentry_sdk.capture_message(cls._extract_value(event), level=level)
